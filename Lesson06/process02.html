<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Lesson06 -02 | 森の描画</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <!-- canvas要素を用意 -->
  <canvas id="canvas"></canvas>
  <!-- Three.js をCDNから読み込む -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
  import { setupThreeEnvironment } from '../three/three-setup.js';
  import { setupPointerLockControls } from '../three/pointer-lock.js';
  import { setupMovement } from '../three/movement.js';
  import * as THREE from 'three';

  // 基本オブジェクト一式
  const canvas = document.querySelector("#canvas");
  const { renderer, scene, camera } = setupThreeEnvironment(canvas);

  // PointerLockControls
  const { controls, isLockedRef } = setupPointerLockControls(camera, renderer.domElement);

  // Movement
  const movement = setupMovement(camera);

  // 森の生成 (幹を表す円柱と葉を表す円錐を組み合わせてランダムに配置)
  for (let i = 0; i < 10; i++) {
    const woodHeight = Math.random() * 10 + 10;
    const trunkHeight = woodHeight / 3;
    const trunkRadius = woodHeight / 18;
    const foliageHeight = woodHeight * 2 / 3;
    const foliageRadius = woodHeight / 4;
    const foliageSegments = Math.ceil(Math.random() * 4) + 4; // 5〜8角錐
    const wood = new THREE.Group();

    // 幹
    const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.85, trunkRadius, trunkHeight, foliageSegments);
    const trunkMat = new THREE.MeshLambertMaterial({ color: 0x442211 });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = trunkHeight / 2;
    trunk.castShadow = trunk.receiveShadow = true;
    wood.add(trunk);

    // 葉
    const foliageGeo = new THREE.ConeGeometry(foliageRadius, foliageHeight, 12);
    const foliageMat = new THREE.MeshLambertMaterial({ color: 0x00ff88 });
    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
    foliage.position.y = trunkHeight + foliageHeight / 2 - 2; // 少し低めにオフセット
    foliage.castShadow = foliage.receiveShadow = true;
    wood.add(foliage);

    // ランダムに配置し、シーンに追加
    wood.position.set(
      (Math.random() - 0.5) * 100,
      0,
      (Math.random() - 0.5) * 100
    );
    scene.add(wood);
  }

  // 毎フレーム呼ばれるループ処理
  function tick() {
    // pointer-lock.js 側の状態を見る
    if (isLockedRef()) {
      // movement.js 側で計算した移動ベクトルをカメラに反映
      const dir = movement.getMovementVector();
      camera.position.add(dir);
    }

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  // Start!!
  tick();

</script>
</body>
</html>
